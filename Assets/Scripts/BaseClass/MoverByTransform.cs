using System;
using UnityEngine;

public class MoverByTransform : MonoBehaviour
{
    /// <summary>
    /// 로컬 좌표를 사용하는가?
    /// </summary>
    [SerializeField]
    private bool isSetByLocal = true;
    /// <summary>
    /// gameobject.position 대체. isSetByLocal가 true면 로컬 좌표를 사용
    /// </summary>
    private Vector2 Position
    {
        get
        {
            if (isSetByLocal)
            {
                return transform.localPosition;
            }
            else
            {
                return transform.position;
            }
        }
        set
        {
            if (isSetByLocal)
            {
                transform.localPosition = value;
            }
            else
            {
                transform.position = value;
            }
        }
    }

    /// <summary>
    /// 이동 타입
    /// </summary>
    public enum moveType
    {
        LinearByPosWithTime,
        LinearByPosWithSpeed,
        LinearBySpeed,
        ByFunction,
    }
    private moveType type;

    //위치 기반 이동 시
    //목표 위치
    private Vector2 targetPos;
    private float targetMoveTime = 0;
    private Vector2 posOrigin = Vector2.zero;

    //속도 기반 이동 시
    //목표 속도
    private Vector2 targetSpeed;
    private float targetSpeedF = 0;

    //함수 사용 시
    Func<float, Vector2> MoveFunction;

    [SerializeField]
    private float moveTimer;//이동 확인용 타이머. ticktimer 만들기 전에 만들어서 float로 사용 중
    [SerializeField]
    private bool isMoving = false;//이동 중인가?
    public bool IsMoving => isMoving;

    //맵 경계를 벗어날 수 있는가?
    [SerializeField]
    private bool canMoveOverMapLimit = true;
    //맵 경계 오프셋
    [SerializeField]
    private float MapLimitExtra = 0;

    private void Update()
    {

        if (isMoving)
        {
            switch (type)
            {
                case moveType.LinearByPosWithTime:
                    MoveLinearByPosWithTime();
                    break;

                case moveType.LinearByPosWithSpeed:
                    MoveLinearByPosWithSpeed();
                    break;

                case moveType.LinearBySpeed:
                    MoveLinearBySpeed();
                    break;

                case moveType.ByFunction:
                    MoveByFunction();
                    break;

                default:
                    break;
            }
        }


        if (!canMoveOverMapLimit)
        {
            transform.position = GameTools.ClampToRect(transform.position, GameManager.MapLimit, MapLimitExtra);
        }
    }

    /// <summary>
    /// 움직임 시작
    /// </summary>
    public void StartMove(moveType type, Vector2 target, params float[] options)
    {
        moveTimer = 0;
        this.type = type;
        posOrigin = Position;
        isMoving = true;

        switch (type)
        {
            case moveType.LinearByPosWithTime:
                targetPos = target;//이동할 위치
                targetMoveTime = Mathf.Max(options[0], 0);//걸리는 시간

                break;

            case moveType.LinearByPosWithSpeed:
                targetPos = target;//이동할 위치
                targetSpeedF = options[0];//이동 속도
                break;

            case moveType.LinearBySpeed:
                targetSpeed = target;//이동할 방향 벡터
                targetMoveTime = options[0];//이동 속도

                break;
            default:
                Debug.LogError("알 수 없는 이동 유형");
                break;
        }
    }

    /// <summary>
    /// 전달받은 함수에 따라 지정된 궤도로 이동.
    /// 패턴 구현 등에 사용할 예정이었으나 기획 변경으로 미사용
    /// </summary>
    public void StartMove(moveType type, float targetTime, Func<float, Vector2> function)
    {
        moveTimer = 0;
        this.type = type;
        posOrigin = Position;
        targetMoveTime = targetTime;
        isMoving = true;

        switch (type)
        {
            case moveType.ByFunction:
                MoveFunction = function;
                break;
            default:
                Debug.LogError("알 수 없는 이동 유형");
                break;
        }

    }

    public void StopMove()
    {
        moveTimer = 0;
        isMoving = false;
    }

    private void MoveLinearByPosWithTime()
    {
        //타이머 체크
        moveTimer += Time.deltaTime;
        if (moveTimer >= targetMoveTime)
        {
            moveTimer = targetMoveTime;
            isMoving = false;
        }

        //시간 비율 계산
        float Ilerp = Mathf.InverseLerp(0, targetMoveTime, moveTimer);

        //시간 비율에 따른 좌표 계산
        float moveX = Mathf.Lerp(posOrigin.x, targetPos.x, Ilerp);
        float moveY = Mathf.Lerp(posOrigin.y, targetPos.y, Ilerp);

        //이동
        Position = new Vector2(moveX, moveY);
    }
    private void MoveLinearByPosWithSpeed()
    {
        //타이머 체크
        moveTimer += Time.deltaTime;
        float targetDist = (targetPos - posOrigin).magnitude;//이동해야 하는 거리
        float targetTime = targetDist / targetSpeedF;//이동에 걸리는 시간


        if (moveTimer >= targetTime)
        {
            Position = targetPos;
            isMoving = false;
            return;
        }

        //시간 비율 계산
        float Ilerp = Mathf.InverseLerp(0, targetTime, moveTimer);

        //시간 비율에 따른 좌표 계산
        float moveX = Mathf.Lerp(posOrigin.x, targetPos.x, Ilerp);
        float moveY = Mathf.Lerp(posOrigin.y, targetPos.y, Ilerp);

        //이동
        Position = new Vector2(moveX, moveY);
    }
    private void MoveLinearBySpeed()
    {
        float deltaTime = Time.deltaTime;
        if (targetMoveTime > 0)
        {
            moveTimer += deltaTime;
            if (moveTimer >= targetMoveTime)
            {
                moveTimer = targetMoveTime;
                isMoving = false;
            }
        }

        Vector2 temp = Position;
        temp.x += deltaTime * targetSpeed.x;
        temp.y += deltaTime * targetSpeed.y;
        Position = temp;
    }

    private void MoveByFunction()
    {
        moveTimer += Time.deltaTime;
        if (moveTimer >= targetMoveTime)
        {
            moveTimer = targetMoveTime;
            isMoving = false;
        }

        Position = MoveFunction(moveTimer);
    }
}
